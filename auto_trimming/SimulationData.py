# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SYdxGaUDLVyRP09B_6aO26lsUhIg0Pbz
"""

!pip install Bio

from google.colab import files
from Bio import SeqIO
import random

# Subir el archivo fasta
uploaded = files.upload()
ruta_fasta = list(uploaded.keys())[0]

# Generar una cadena de ADN aleatoria con la longitud que queremos para cada caso
def generar_cadena(longitud):
    bases = ['A', 'T', 'C', 'G']
    cadena = ''.join(random.choices(bases, k=longitud))
    return cadena

# Función para generar datos de entrenamiento en formato FASTA para cada caso
def datos_entrenamiento(caso):
    total_length = 20000
    sequences = []
    with open(ruta_fasta, "r") as fasta_file:
        sequences = list(SeqIO.parse(fasta_file, "fasta"))
    if caso == 1:
        total_length = 20000
        starting_pos_1 = random.randint(0, total_length/2)
        random_sequence1 = random.choice(sequences)
        min_starting_pos_1 = min(len(random_sequence1.seq), total_length // 2)
        starting_pos_1 = random.randint(min_starting_pos_1, total_length / 2)
        random_sequence2 = random.choice(sequences)
        min_starting_pos_2 = min(starting_pos_1 + len(random_sequence1.seq), total_length - len(random_sequence1.seq))
        starting_pos_2 = random.randint(min_starting_pos_2, total_length - int(total_length * 0.1))
        final_seq = generar_cadena(starting_pos_1) + random_sequence1.seq
        final_seq += generar_cadena(starting_pos_2 - len(random_sequence1.seq))
        final_seq += random_sequence2.seq

        if len(final_seq) < total_length:
            missing = total_length - len(final_seq)
            final_seq += generar_cadena(missing)

        final_seq = final_seq[:total_length]
        final_seq_len = len(random_sequence1.seq)
        return f">Caso{caso}_{random_sequence1.id}_{starting_pos_1}_{final_seq_len}\n{final_seq}"

    elif caso == 2:
        sequence_1 = ""
        sequence_2 = ""
        while len(sequence_1) < total_length // 3:
            random_sequence1 = random.choice(sequences)
            sequence_1 += str(random_sequence1.seq)
        while len(sequence_2) < total_length // 3:
            random_sequence2 = random.choice(sequences)
            sequence_2 += str(random_sequence2.seq)

        seq_final = sequence_1 + sequence_2 + sequence_1
        missing = int((total_length - len(seq_final)) / 2) + 1
        if len(seq_final) < total_length:
          # AQUI ESTABA LA DEF DE MISSING
          seq_final = generar_cadena(missing) + seq_final + generar_cadena(missing)
          print(len(seq_final))

        seq_final = seq_final[0:total_length]
        starting_pos = len(sequence_1) + missing
        seq_len = len(sequence_2)
        return f">Caso{caso}_{random_sequence2.id}_{starting_pos}_{seq_len}\n{seq_final}"
    elif caso == 3:
        # Generar el microsatélite
        monomer_length = random.randint(5, 100)
        monomer = generar_cadena(monomer_length)
        random_sequence = random.choice(sequences)
        start_pos = random.randint((total_length/2) - (total_length/2)*0.1, (total_length/2) + (total_length/2)*0.1)
        sequence_length = len(random_sequence.seq)

        # Rellenar hasta la posición 10,000 con el mismo microsatélite
        microsatelite = ""
        while len(microsatelite) < start_pos:
            microsatelite += monomer

        microsatelite += random_sequence.seq
        # Rellenar desde el final de la secuencia hasta la posición 25,000
        while len(microsatelite) < total_length:
            microsatelite += monomer
        microsatelite = microsatelite[0:total_length]

        return f">Caso{caso}_{random_sequence.id}_{start_pos}_{sequence_length}\n{microsatelite}"
# Uso de la función con cada caso
caso_1 = datos_entrenamiento(1)
caso_2 = datos_entrenamiento(2)
caso_3 = datos_entrenamiento(3)
with open("salida.fasta", "w") as archivo_salida:
    for caso in range(1, 4):
        for n in range(1, 3001):
            secuencia = datos_entrenamiento(caso)
            archivo_salida.write(secuencia + "\n")

files.download("salida.fasta")